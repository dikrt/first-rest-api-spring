# Task2_A" <br>
![](images/s2.png) <br> <br>


**We started with creating a project tree** <br>
![](images/s3.png) <br> <br>

**We started with filling our classes with code starting with `Domain/product`** <br>
![](images/s4.png) <br> <br>

`private Long id;` This will be the unique identifier for the product <br>
`private String name;` The name of the product <br>
`public Product(String name) { this.name = name; }` This is a parameterized constructor used to create a new instance of the Product class with a specific name <br>
`public Long getId() { return id; }` This method is used to retrieve the unique identifier (id) of a product <br>
`public void setId(Long id) { this.id = id; }` This method allows the application to assign or change the id of a product <br>
`public String getName() { return name; }` This method retrieves the current name of the product <br>
`public void setName(String name) { this.name = name; }` This method is used to set or update the name of the product <br> <br>

**We are filling the `Repository/ProductRepository`** <br>
![](images/s5.png) <br> <br>

`@Repository:` Tells Spring this class communicates with the data storage <br>
`Map<Long, Product>:` Acts as our "temporary database" <br>
`counter:` Ensures every product saved has a unique, incrementing ID <br>
`save():` The standard method name used in Spring for adding or updating data <br>

We are filling the `Api/ProductRequest` and `Api/ProductResponse` <br>
![](images/s6.png) <br> <br>
![](images/s7.png) <br> <br>


`ProductRequest:` uses the @JsonCreator annotation, which tells the Jackson library (built into Spring) how to create this Java object from JSON text <br>
`ProductResponse:` Unlike the request, the response includes the ID generated by our "database" so the user knows which ID was assigned to their new product  <br>

**Why two classes?:** We separate them because the user provides the name (Request), but the server provides both the name and the generated ID (Response) <br> <br>


We are filling the `support/ProductMapper` <br>
![](images/s8.png) <br> <br>

**Why use a Mapper?:** It keeps your code clean by separating the data formats used by the "outside world" (API) from the internal data formats (Domain). <br>
`@Component`: This makes the class a Spring Bean, allowing the ProductService to use it automatically through dependency injection. <br> <br>

We are filling the `service/ProductService` <br>
![](images/s9.png) <br> <br>

`Dependency Injection:` We use the constructor to bring in the Repository and Mapper, ensuring the Service has all the tools it needs <br>
`Business Logic Flow:` The create method handles the logic of transforming an incoming request into a database entity and then into a user-friendly response <br>
`Encapsulation:` The Service layer ensures the Controller doesn't have to deal with the Repository directly, which is a key part of professional software architecture <br> <br>

We are filling the `response/ProductController` <br>
![](images/s10.png) <br> <br>

`Request Handling:` The `@RequestBody` annotation is the mechanism that "rewrites" JSON data into a Java object <br>
`Response Status:` We use 201 Created because it is the standard HTTP success code for a resource being saved correctly <br>
`Flow:` The controller receives the request, passes it to the ProductService, and wraps the result in a ResponseEntity for the client <br> <br>

We downloaded post and tested the API in postman in the screenshot you can see the result <br>
![](images/s11.png) <br> <br>

We add `find method` the `Repository/ProductRepository` <br>
![](images/s12.png) <br> <br>

This uses the get() method of the HashMap to quickly find the object associated with that specific ID key. <br> <br>

We add `find method` the `Api/ProductController` <br>
![](images/s13.png) <br> <br>

`@GetMapping("/{id}"):` This tells Spring to handle GET requests at `/api/v1/products/{id}` <br>
`@PathVariable:` This takes the value from the URL (the {id} part) and converts it into the Java variable id so the service can use it to search the HashMap <br> <br>

We update `find method` in the `repository/ProductRepository` <br>
![](images/s14.png) <br> <br>

`Optional.ofNullable:` This wraps the result. If the product exists, it contains the product; if not, it returns an "empty" Optional instead of a crash-prone null. <br> <br>

We update `Optional find` in the `service/Productservice` <br>
![](images/s15.png) <br> <br>

`.orElseThrow():` This tells the code: "Give me the product if it's there, otherwise stop and throw an error" <br> <br>

# Task2_B" <br>
![](images/s16.png) <br> <br>

To enable Swagger we must add a specific library to our pom.xml file after doing that we can reload the maven project  <br>
![](images/s17.png) <br> <br>

We added `findALL  method` in the `repository/ProductRepository` <br>
![](images/s19.png) <br> <br>
It will let us converts the collection of products stored in our HashMap into a List format that Java can easily loop through. <br> <br>

screenshot of `localhost:8080/swagger-ui/index.html` and `localhost:8080/v3/api-docs`
![](images/s19.png) <br> <br>
![](images/s20.png) <br> <br>


# Task2_C" <br>
![](images/s21.png) <br> <br>

We added required Imports and inserted the GET method code <br>
![](images/s22.png) <br> <br>
`@GetMapping("/{id}"):` This annotation maps HTTP GET requests to /api/v1/products/{id}. <br>
`@PathVariable Long id:` This tells Spring to extract the ID value from the URL and pass it into the method. <br>
`@Operation:` This is a Swagger annotation that describes the endpoint in our UI <br> <br>

We update the code in the `ProductService` <br>
![](images/s23.png) <br> <br>
`What it does:` It asks the repository for a product by its ID. If the product exists, it uses the ProductMapper to change the Product object into a ProductResponse. If it doesn't exist, it throws an exception. <br>
after that we update the repository layer <br>
![](images/s24.png) <br> <br>

**GET - Find Product by ID** <br>
![](images/s25.png) <br> <br>
The endpoint allows the user to retrieve a specific product from the "database" by providing its unique ID in the URL path in our case `http://localhost:8080/api/v1/products/1`. <br> <br>

**overview of Task2_C** <br>

`Endpoint Definition:` The find() method in our controller is responsible for handling the request because it is marked with the @GetMapping("/ {id}") annotation <br>
`Path Variables:` The {id} in the URL is a placeholder for the resource identifier. <br>
`Mapping the ID:` Spring automatically assigns the value from the URL (`http://localhost:8080/api/v1/products/1`) to the Long id parameter in our Java method. <br>
`The Role of @PathVariable:` This assignment happens because the parameter is marked with the @PathVariable annotation and shares the same name ("id") as the attribute in the @GetMapping annotation. <br>
`Next Action:` Once the ID is captured, the controller calls productService.find(id) to begin the data retrieval process. <br>
**To meet the requirement of detailing all use cases, we're adding a note about the current error state:** <br>
`Error Handling (Current):` Currently, requesting an invalid ID returns an HTTP 500 error. this will change in the future of our code. <br> <br> 


# Task2_D" <br>
![](images/s26.png) <br> <br>

We created `ProductNotFoundException` Class inside `exception` package <br>
![](images/s27.png) <br> <br>

We added code in the class <br>
![](images/s28.png) <br> <br>
`ProductNotFoundException` ensures that when a user searches for a product ID that does not exist, the system generates a clear, formatted message rather than a generic crash <br> <br>

We created `ProductExceptionSupplier` Class inside `support` package <br>
![](images/s29.png) <br> <br>

We added code in the class <br>
![](images/s30.png) <br> <br>
`ProductExceptionSupplier` allows you to add more product-related exceptions in the future in one central place. <br> <br>

We created `ProductExceptionAdviso` Class inside `support` package <br>
![](images/s31.png) <br> <br>

We added code in the class <br>
![](images/s32.png) <br> <br>

`@ControllerAdvice:` Tells Spring this class handles exceptions globally. <br> 
`@ExceptionHandler:` Specifies that this method only triggers when a ProductNotFoundException occurs. <br>
`@ResponseStatus(HttpStatus.NOT_FOUND):` This is what changes the HTTP status code from 500 to 404. <br>
`ErrorMessageResponse:` This is a wrapper class for the error message <br> <br>

We created `SharedApiResponse` package outside of product and `ErrorMessageResponse` class <br>
![](images/s33.png) <br> <br>

We added code in the class <br>
![](images/s34.png) <br> <br>
This class is a simple wrapper (POJO) used to store an error message as a final string, providing a standardized JSON structure for the API's error responses. <br> <br>

# Task2_E" <br>
![](images/s35.png) <br> <br>

We added a new method to ProductController to handle update requests. This method uses the @PutMapping annotation with a path variable for the product ID. <br>
![](images/s36.png) <br> <br>


We created `UpdateProductRequest` class in `Request` package <br>
![](images/s37.png) <br> <br>

We added code in the class <br>
![](images/s38.png) <br> <br>


We implemented the update method within the `ProductService` class. <br> 
![](images/s39.png) <br> <br>
The `update` method in the `ProductService` class retrieves an existing product by its ID, uses a specialized mapper to apply the updated data from the request, and then persists the changes back to the repository. <br><br>


We are solving the compilation error in the service layer by updating the `ProductMapper` class to handle the mapping of an existing product with new data. <br>
![](images/s40.png) <br> <br>

We updated the logic in `ProductRepository` to handle updates correctly. <br>
![](images/s41.png) <br> <br>
**Why ?** This ensures that if the product already has an ID (an update), it just saves it to the map. If it doesn't (a new product), it generates a new ID using the counter. <br> <br>


# Task2_F" <br>
![](images/s42.png) <br> <br>

We added code in the class `ProductController` <br>
![](images/s43.png) <br> <br>
This controller method maps HTTP DELETE requests to a specific product ID, delegating the removal logic to the service layer and returning a 204 No Content status to confirm successful deletion without sending back a response body. <br> <br>

We added code in the class `ProductService` <br>
![](images/s44.png) <br> <br>
delegates the removal task to the repository by calling its delete function with the specified product identifier <br> <br>

We added code in the class `ProductRepository` <br>
![](images/s45.png) <br> <br>
executes the actual data removal by using the built-in remove function of the Java Map to delete the entry associated with the given ID. <br> <br> 


We added code in the class `ProductService` <br>
![](images/s46.png) <br> <br>
We updated the method with a validation step that verifies the resource's existence via findById before removal, ensuring that requests for non-existent IDs are met with a standardized 404 Not Found error response. <br>

We added code in the class `ProductRepositorr` <br>
![](images/s47.png) <br> <br>
This method simply performs a standard removal of the key-value pair from your in-memory `HashMap`. <br> <br>

# Task2_G" <br>
![](images/s48.png) <br> <br>


We added code in the class `src -> main -> resources -> application.properties` <br>
![](images/s49.png) <br> <br>
`(enabled=true):` This turns on the web-based "H2 Console," which is a visual tool that lets you see and manage our database tables directly in a browser. <br>
`(path=/console/):` This defines the URL address we will use to access that console (localhost:8080/console/). <br>
`(url=jdbc:h2:mem:testdb):` This defines the "Schema." It ensures that every time we run the app, it uses a database with the same consistent name (testdb). <br> <br>
The result <br>
![](images/s50.png) <br> <br>

We changed the `JDBC URL:` from default **jdbc:h2:mem:testdb** to match ours  <br>
![](images/s51.png) <br> <br>

Result after loggin in <br>
![](images/s52.png) <br> <br>

We need to go back to our applications.properties file again and add code  <br>
![](images/s53.png) <br> <br>
This line tells Spring Boot to print every SQL query that Hibernate runs into our IntelliJ console  <br>

Result  <br>
![](images/s54.png) <br> <br>

